#!/usr/bin/env bash

#
# This script will automatically generate _posts/release/*.md entries as "Project News" posts for the
# tagged DataWave releases that it discovers on the configured repo. The script can optionally commit and push
# the posts to the remote gh-pages branch, if desired. See DW_GITHUB_REMOTE_URL notes below
#
# Intended to be non-interactive and suitable for crond or other automation
#
# Note that fresh git clones are created in /tmp and then deleted each time the script runs.
# No persistent local repo is required on the client host. 
#

#############################################################################
# DW_GITHUB_REMOTE_URL
#############################################################################
# Github repo to read from and optionally update. By default,
# DW_GITHUB_REMOTE_URL is defined as
#   https://github.com/NationalSecurityAgency/datawave.git
# However, if --push is used, then it must be overridden as
#   https://user:token@github.com/NationalSecurityAgency/datawave.git
# where 'user:token' has write permissions on the repo
DW_GITHUB_REMOTE_URL="${DW_GITHUB_REMOTE_URL:-https://github.com/NationalSecurityAgency/datawave.git}"

############################################################################# 
# TRACKED_DW_VERSIONS
#############################################################################
# Major versions of DW that we want to track for publishing purposes. For
# example, any pre-5.x releases that are created at this point are unlikely
# to be of interest to anyone except the development team. Hence, we're not
# tracking the 3.x line here. To start/stop auto-publishing news updates for
# a release line, just add/remove the major version to/from the array
declare -a -r TRACKED_DW_VERSIONS=( 5 6 7 )
 
readonly TMP_DW_DIR=$(mktemp -d /tmp/$( basename $0 )_datawave_XXXXXXX)
readonly TMP_GHPAGES_DIR=$(mktemp -d /tmp/$( basename $0 )_ghpages_XXXXXXX)
readonly POSTS_DIR=${TMP_GHPAGES_DIR}/_posts/release

declare -i _new_release_count=0

_debug=false
_dry_run=true
_force_clean=false

log() {
  echo "[$(date +%Y-%m-%d\ %H:%M:%S)] "${@}""
}

logd() {
  [[ "${_debug}" == true ]] && log "[DEBUG] ${1}"
}

logi() {
  log "[INFO] ${1}"
}

logw() {
  log "[WARN] ${1}"
}

loge() {
  log "[ERROR] ${1}"
}

logf() {
  log "[FATAL] ${1}"
  exit 1
}

clone_repos() {
  logi "Cloning repos..."
  if ! ${GIT} clone ${GIT_QUIET} "${DW_GITHUB_REMOTE_URL}" ${TMP_DW_DIR} ; then
    logf "Failed to clone DataWave!"
  fi
  logi "DataWave was cloned to ${TMP_DW_DIR}"
  if ! ${GIT} clone ${GIT_QUIET} --single-branch --branch gh-pages "${DW_GITHUB_REMOTE_URL}" ${TMP_GHPAGES_DIR} ; then
    logf "Failed to clone DataWave's gh-pages branch!"
  fi
  logi "gh-pages branch was cloned to ${TMP_GHPAGES_DIR}"
}

usage() {
cat <<EOF
Usage:
  $( basename "$0" ) [--push, -p] [--force-cleanup, -f] [--verbose, -v] [--help, -h]
Options:
  --push, -p          | Commit and push changes to DW_GITHUB_REMOTE_URL
  --verbose, -v       | Turn on debug mode
  --force-cleanup, -f | Remove gh-pages clone from /tmp, even if changes were made
  --help, -h          | Print this usage information and exit
EOF
exit 0
}

configure() {
  while [[ "${1}" != "" ]]; do
    case "${1}" in
      --verbose | -v)
         _debug=true
         ;;
      --push | -p)
         _dry_run=false
         ;;
      --force-cleanup | -f)
         _force_clean=true
         ;;
      --help | -h)
         usage
         ;;
      *)
         loge "Invalid argument: '${1}'"
         usage
    esac
    shift
  done
  
  readonly GIT=$(which git)
  [[ -z "${GIT}" ]] && logf "Can't locate git exe!"
  [[ -z "${DW_GITHUB_REMOTE_URL}" ]] && logf "DW_GITHUB_REMOTE_URL is not set in your environment!"
  [[ "${_debug}" == false ]] && readonly GIT_QUIET="--quiet"
  
  clone_repos
}

search() {
  # Return array index of the search term, if found. -1 otherwise
  local _searchTerm=${1}
  shift
  local _arr=("$@")
  local i=0;
  for str in "${_arr[@]}" ; do
    if [[ "$str" == "${_searchTerm}" ]] ; then
      echo $i
      return
    else
      ((i++))
    fi
  done
  echo "-1"
}

cleanup() {
  local _dirs=("$@")
  for dir in "${_dirs[@]}" ; do
    if [[ -d "${dir}" ]] ; then
      if [[ "${dir}" == /tmp/*"$( basename $0 )"* ]] ; then
        rm -rf "${dir}" && logi "Deleted ${dir}"
      else
        logw "I can't delete this directory: ${dir}"
      fi
    fi
  done
}

generate_posts() {
  local _start_index=${1} ; shift
  local _arr=("$@")
  for ((i=${_start_index}; i<${#_arr[@]}; i++)) ; do
    create_post ${_arr[i]}
  done
}

create_post() {
  local _accumulo_version="2.1"
  [[ ${_major_version} -lt 5 ]] && _accumulo_version="1.10"
  local _yyyymmdd=$(cd ${TMP_DW_DIR} && ${GIT} for-each-ref --format="%(creatordate:short)" refs/tags/${1})
  local _post_file_name="${POSTS_DIR}/${_yyyymmdd}-datawave-${1}.md"
  local _post="---
title: DataWave ${1}
version: ${1}
tags: [news, releases]
draft: false
---
A new Accumulo ${_accumulo_version}.x-compatible DataWave release has been tagged

[View the release on GitHub]({{ site.repository_url }}/releases/tag/{{ page.version }})
"
  logi "Generating post for '${1}' @ ${_post_file_name}"
  echo "${_post}" > ${_post_file_name}
  ((_new_release_count++))
}

update_git() {
  local _commit_message="Publishing update for new DW tagged release(s)"
  cd "${TMP_GHPAGES_DIR}"
  ${GIT} add . || logf "Failed to git-add updates to local gh-pages branch!"
  logi "======================== BEGIN git diff ============================="
  ${GIT} diff HEAD
  logi "======================== END git diff ==============================="
  if [[ "${_dry_run}" == false ]] ; then
    ${GIT} commit -m "${_commit_message}" || logf "Failed to git-commit changes on local gh-pages branch!"
    ${GIT} push origin gh-pages || logf "Failed to push gh-pages update to remote repository"
    logi "Commit for ${_new_release_count} new release(s) pushed to remote repository"
  else
    logi "Skipping commit/push to remote repository"
  fi
}

get_dw_tags() {
  #
  # Get semver-sorted list of tags for the current _major_version
  # Filter out RC's and other cruft
  #
  _dw_tags=( $(cd ${TMP_DW_DIR} && $GIT tag --sort=v:refname | egrep "^${_major_version}\.[0-9]+\.[0-9]+$") )
}

get_published_tags() {
  #
  # Get semver-sorted list of tagged releases for the current _major_version
  # that've already been published to gh-pages
  #
  _ghpages_posts=()
  _ghpages_posts_count=$(ls -1 ${POSTS_DIR}/*datawave-${_major_version}\.* 2>/dev/null | wc -l)

  if [[ ${_ghpages_posts_count} -eq 0 && ${#_dw_tags[@]} -gt 0 ]] ; then
    logi "Latest release is ${_dw_tags[-1]}, but we haven't published any ${_major_version}.x entries yet"
    logi "Seeding gh-pages with the ${_dw_tags[0]} entry"
    create_post ${_dw_tags[0]}
    _ghpages_posts_count=1
  fi

  if [[ ${_ghpages_posts_count} -gt 0 ]] ; then
    _ghpages_posts=( $(cd ${POSTS_DIR} && ls -1 *datawave-${_major_version}\.*\.md | cut -d'-' -f5 | sed 's/.\{3\}$//' | sort -t "." -k1,1n -k2,2n -k3,3n) )
    # Get the _DW_TAGS index of the most recent tag published to ghpages
    _latest_post_index=$(search "${_ghpages_posts[-1]}" "${_dw_tags[@]}")
  fi

  # Sanity check...
  if [[ ${_ghpages_posts_count} -gt 0 && ${_latest_post_index} -lt 0 ]] ; then
    logf "Git tag for the ${_ghpages_posts[-1]} gh-pages post wasn't found in Github"
  fi

  logi "Latest ${_major_version}.x post in gh-pages: ${_ghpages_posts[-1]}"
  logi "Latest DW ${_major_version}.x release: ${_dw_tags[-1]}"
  logd "${_major_version}.x tag list: $(printf '%s\n' "${_dw_tags[@]}" | paste -sd ',' -)"
  logd "Index of ${_ghpages_posts[-1]} tag: ${_latest_post_index}"
}

configure "${@}"

# Update gh-pages' _posts/release to reflect latest DW releses for all tracked versions  

for _major_version in "${TRACKED_DW_VERSIONS[@]}" ; do
  get_dw_tags
  get_published_tags
  # If latest published tag != latest DW tag, then we need to publish an update
  if [[ "${_ghpages_posts[-1]}" != "${_dw_tags[-1]}" ]] ; then
    generate_posts "$((${_latest_post_index}+1))" "${_dw_tags[@]}"
  else
    logi "There's nothing new to publish for DW ${_major_version}.x"
  fi
done

# Update local gh-pages git repo and do cleanup as needed
cleanup "${TMP_DW_DIR}"
if [[ ${_new_release_count} -gt 0 ]] ; then
  logi "New releases since the last gh-pages update: ${_new_release_count}"
  update_git
  if [[ "${_force_clean}" == true ]] ; then
    cleanup "${TMP_GHPAGES_DIR}"
  else
    logw "Leaving ${TMP_GHPAGES_DIR} intact, because there were changes made"
  fi
else
  cleanup "${TMP_GHPAGES_DIR}"
fi

exit 0
