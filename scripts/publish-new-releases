#!/usr/bin/env bash

#
# This script is intended to be non-interactive and suitable for crond or other automation.
#
# The script will automatically generate (and optionally commit & push) _posts/release entries for
# the gh-pages branch, i.e., for newly tagged DW releases that are discovered on DW_GITHUB_REMOTE_URL.
# Currently, we look for new 3.x, 5.x and 6.x updates, for Accumulo 1.10.x- and 2.1.x-compatible DW releases.
#
# Usage:
#   <script-name> [--push, -p] [--verbose, -v] [--help, -h]
#
# Use of '--push (-p)' option will attempt to commit and push changes to DW_GITHUB_REMOTE_URL
#
# Prerequisites:
#   (1) DW_GITHUB_REMOTE_URL must be defined in the user's environment
#   (2) The git executable must be on the user's PATH
#

# Major versions of DW that we want to publish to the gh-pages site
declare -a -r TRACKED_DW_VERSIONS=( 3 5 6 )

readonly TMP_DW_DIR=$(mktemp -d /tmp/$( basename $0 )_datawave_XXXXXXX)
readonly TMP_GHPAGES_DIR=$(mktemp -d /tmp/$( basename $0 )_ghpages_XXXXXXX)
readonly POSTS_DIR=${TMP_GHPAGES_DIR}/_posts/release


declare -i _new_release_count=0

_debug=false
_dry_run=true

log() {
  echo "[$(date +%Y-%m-%d\ %H:%M:%S)] "${@}""
}

logd() {
  [[ "${_debug}" == true ]] && log "[DEBUG] ${1}"
}

logi() {
  log "[INFO] ${1}"
}

logw() {
  log "[WARN] ${1}"
}

loge() {
  log "[ERROR] ${1}"
}

logf() {
  log "[FATAL] ${1}"
  exit 1
}

usage() {
  echo "Usage:"
  echo " $( basename "$0" ) [--push, -p] [--verbose, -v] [--help, -h]"
  echo "Options:"
  echo " --push, -p    | Commit and push changes to DW_GITHUB_REMOTE_URL"
  echo " --verbose, -v | Turn on debug mode"
  echo " --help, -h    | Print this usage information and exit"
  exit 0
}

configure() {
  while [[ "${1}" != "" ]]; do
    case "${1}" in
      --verbose | -v)
         _debug=true
         shift
         ;;
      --push | -p)
         _dry_run=false
         shift
         ;;
      --help | -h)
         usage
         ;;
      *)
         loge "Invalid argument: '${1}'"
         usage
    esac
    shift
  done
  
  readonly GIT=$(which git)
  [[ -z "${GIT}" ]] && logf "Can't locate git exe!"
  [[ -z "${DW_GITHUB_REMOTE_URL}" ]] && logf "DW_GITHUB_REMOTE_URL is not set in your environment!"
  [[ "${_debug}" == false ]] && readonly GIT_QUIET="--quiet"
  
  clone_repos
}

search() {
  # Return array index of the search term, if found. -1 otherwise
  local _searchTerm=${1}
  shift
  local _arr=("$@")
  local i=0;
  for str in "${_arr[@]}" ; do
    if [[ "$str" == "${_searchTerm}" ]] ; then
      echo $i
      return
    else
      ((i++))
    fi
  done
  echo "-1"
}

cleanup() {
  local _dirs=("$@")
  for dir in "${_dirs[@]}" ; do
    if [[ -d "${dir}" ]] ; then
      if [[ "${dir}" == /tmp/*"$( basename $0 )"* ]] ; then
        rm -rf "${dir}" && logi "Deleted ${dir}"
      else
        logw "I can't delete this directory: ${dir}"
      fi
    fi
  done
}

generate_posts() {
  local _accumulo_minor_v=${1} ; shift
  local _start_index=${1} ; shift
  local _arr=("$@")
  for ((i=${_start_index}; i<${#_arr[@]}; i++)) ; do
    local _yyyymmdd=$(cd ${TMP_DW_DIR} && ${GIT} for-each-ref --format="%(creatordate:short)" refs/tags/${_arr[i]})
    local _post_file_name="${POSTS_DIR}/${_yyyymmdd}-datawave-${_arr[i]}.md"
    local _post="---
title: DataWave ${_arr[i]}
version: ${_arr[i]}
tags: [news, releases]
draft: false
---
A new Accumulo ${_accumulo_minor_v}.x-compatible DataWave release has been tagged

[View the release on GitHub]({{ site.repository_url }}/releases/tag/{{ page.version }})
"
    logi "Generating post for '${_arr[i]}' @ ${_post_file_name}"
    echo "${_post}" > ${_post_file_name}
    ((_new_release_count++))
  done
}

update_git() {
  local _commit_message="Publishing update for new DW tagged release(s)"
  cd "${TMP_GHPAGES_DIR}"
  ${GIT} add . || logf "Failed to git-add updates to local gh-pages branch!"
  logi "======================== BEGIN git diff ============================="
  ${GIT} diff HEAD
  logi "======================== END git diff ==============================="
  if [[ "${_dry_run}" == false ]] ; then
    ${GIT} commit -m "${_commit_message}" || logf "Failed to git-commit changes on local gh-pages branch!"
    ${GIT} push origin gh-pages || logf "Failed to push gh-pages update to remote repository"
    logi "Commit for ${_new_release_count} new release(s) pushed to remote repository"
  else
    logi "Skipping commit/push to remote repository"
  fi
}

clone_repos() {
  logi "Cloning repos..."
  if ! ${GIT} clone ${GIT_QUIET} "${DW_GITHUB_REMOTE_URL}" ${TMP_DW_DIR} ; then
    logf "Failed to clone DataWave!"
  fi
  logi "DataWave was cloned to ${TMP_DW_DIR}"
  if ! ${GIT} clone ${GIT_QUIET} --single-branch --branch gh-pages "${DW_GITHUB_REMOTE_URL}" ${TMP_GHPAGES_DIR} ; then
    logf "Failed to clone DataWave's gh-pages branch!"
  fi
  logi "gh-pages branch was cloned to ${TMP_GHPAGES_DIR}"
}

get_dw_tags() {
  #
  # Get semver-sorted list of tags for the current _major_version
  # Filter out RC's and other cruft
  #
  _dw_tags=( $(cd ${TMP_DW_DIR} && $GIT tag --sort=v:refname | egrep "^${_major_version}\.[0-9]+\.[0-9]+$") )
}

get_published_tags() {
  #
  # Get semver-sorted list of tagged releases for the current _major_version
  # that've already been published to gh-pages
  # 
  _ghpages_posts=()
  _ghpages_posts_count=$(ls -1 ${POSTS_DIR}/*datawave-${_major_version}\.* 2>/dev/null | wc -l)
  if [[ ${_ghpages_posts_count} -gt 0 ]] ; then
    _ghpages_posts=( $(cd ${POSTS_DIR} && ls -1 *datawave-${_major_version}\.*\.md | cut -d'-' -f5 | sed 's/.\{3\}$//' | sort -t "." -k1,1n -k2,2n -k3,3n) )
    # Get the _DW_TAGS index of the most recent tag published to ghpages
    _latest_post_index=$(search "${_ghpages_posts[-1]}" "${_dw_tags[@]}")
  fi
  # Sanity check...
  if [[ ${_ghpages_posts_count} -gt 0 && ${_latest_post_index} -lt 0 ]] ; then
    logf "Git tag for the ${_ghpages_posts[-1]} gh-pages post wasn't found in Github"
  fi
  logi "Latest ${_major_version}.x post in gh-pages: ${_ghpages_posts[-1]}"
  logi "Latest DW ${_major_version}.x release: ${_dw_tags[-1]}"
  logd "${_major_version}.x tag list: $(printf '%s\n' "${_dw_tags[@]}" | paste -sd ',' -)"
  logd "Index of ${_ghpages_posts[-1]} tag: ${_latest_post_index}"
}

configure "${@}"

# Update gh-pages' _posts/release to reflect latest DW releses for all tracked versions  

for _major_version in "${TRACKED_DW_VERSIONS[@]}" ; do
  get_dw_tags
  get_published_tags
  # If latest published tag != latest DW tag, then we need to publish an update
  if [[ "${_ghpages_posts[-1]}" != "${_dw_tags[-1]}" ]] ; then
    _accumulo_version="2.1"
    [[ ${_major_version} -lt 5 ]] && _accumulo_version="1.10" 
    generate_posts "${_accumulo_version}" "$((${_latest_post_index}+1))" "${_dw_tags[@]}"
  else
    logi "There's nothing new to publish for DW ${_major_version}.x"
  fi
done

# Update local gh-pages git repo and do cleanup as needed

if [[ ${_new_release_count} -eq 0 ]] ; then
  cleanup "${TMP_GHPAGES_DIR}" "${TMP_DW_DIR}"
else
  logi "New releases since the last gh-pages update: ${_new_release_count}"
  update_git
  cleanup "${TMP_DW_DIR}"
  logw "Leaving ${TMP_GHPAGES_DIR} intact, because there were changes made"
fi

exit 0
