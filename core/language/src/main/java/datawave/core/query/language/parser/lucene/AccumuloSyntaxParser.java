/* Generated By:JavaCC: Do not edit this line. AccumuloSyntaxParser.java */
package datawave.core.query.language.parser.lucene;

import java.io.StringReader;
import java.util.Vector;

import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.FunctionQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.NotBooleanQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
import org.apache.lucene.queryparser.flexible.core.util.UnescapedCharSequence;
import org.apache.lucene.queryparser.flexible.messages.Message;
import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;

@SuppressWarnings("all")
public class AccumuloSyntaxParser implements SyntaxParser, AcumuloSyntaxParserConstants {

    private static final int CONJ_NONE = 0;
    private static final int CONJ_AND = 2;
    private static final int CONJ_OR = 2;

    // syntax parser constructor
    public AccumuloSyntaxParser() {
        this(new FastCharStream(new StringReader("")));
    }

    /**
     * Parses a query string, returning a {@link QueryNode}.
     *
     * @param query
     *            the query string to be parsed.
     * @throws ParseException
     *             if the parsing fails
     */
    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
        ReInit(new FastCharStream(new StringReader(query.toString())));
        try {
            // TopLevelQuery is a Query followed by the end-of-input (EOF)
            QueryNode querynode = TopLevelQuery(field);
            return querynode;
        } catch (ParseException tme) {
            QueryNodeParseException e = new QueryNodeParseException(tme);
            e.setQuery(query);
            throw e;
        } catch (Error tme) {
            Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
            QueryNodeParseException e = new QueryNodeParseException(tme);
            e.setQuery(query);
            e.setNonLocalizedMessage(message);
            throw e;
        }
    }

    // * Query ::= ( Clause )*
    // * Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
    final public int Conjunction() throws ParseException {
        int ret = CONJ_NONE;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case AND:
            case OR:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case AND:
                        jj_consume_token(AND);
                        ret = CONJ_AND;
                        break;
                    case OR:
                        jj_consume_token(OR);
                        ret = CONJ_OR;
                        break;
                    default:
                        jj_la1[0] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[1] = jj_gen;
                ;
        }
        {
            if (true)
                return ret;
        }
        throw new Error("Missing return statement in function");
    }

    final public ModifierQueryNode.Modifier Modifiers() throws ParseException {
        ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NOT:
                jj_consume_token(NOT);
                ret = ModifierQueryNode.Modifier.MOD_NOT;
                break;
            default:
                jj_la1[2] = jj_gen;
                ;
        }
        {
            if (true)
                return ret;
        }
        throw new Error("Missing return statement in function");
    }

    // This makes sure that there is no garbage after the query string
    final public QueryNode TopLevelQuery(CharSequence field) throws ParseException {
        QueryNode q;
        q = ModClause(field);
        jj_consume_token(0);
        {
            if (true)
                return q;
        }
        throw new Error("Missing return statement in function");
    }

    // These changes were made to introduce operator precedence:
    // - Clause() now returns a QueryNode.
    // - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
    // - Query does not consume conjunctions (AND, OR) anymore.
    // - This is now done by two new non-terminals: ConjClause and DisjClause
    // The parse tree looks similar to this:
    // Query ::= DisjQuery ( DisjQuery )*
    // DisjQuery ::= ConjQuery ( OR ConjQuery )*
    // ConjQuery ::= Clause ( AND Clause )*
    // Clause ::= [ Modifier ] ...
    final public QueryNode ModClause(CharSequence field) throws ParseException {
        QueryNode first, q;
        Vector clauses = null;
        ModifierQueryNode.Modifier mods = null;
        first = DisjQuery(field);
        while ((mods = Modifiers()) == ModifierQueryNode.Modifier.MOD_NOT) {
            if (clauses == null) {
                clauses = new Vector();
                clauses.addElement(first);
            }
            q = DisjQuery(field);
            QueryNode m = new ModifierQueryNode(q, mods);
            clauses.addElement(m);
        }

        if (clauses != null) {
            {
                if (true) {
                    if (true)
                        return new NotBooleanQueryNode(clauses);
                }
            }
        } else {
            {
                if (true) {
                    if (true)
                        return first;
                }
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryNode DisjQuery(CharSequence field) throws ParseException {
        QueryNode first, c;
        Vector clauses = null;
        first = ConjQuery(field);
        label_1: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case OR:
                    ;
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    break label_1;
            }
            jj_consume_token(OR);
            c = ConjQuery(field);
            if (clauses == null) {
                clauses = new Vector();
                clauses.addElement(first);
            }
            clauses.addElement(c);
        }
        if (clauses != null) {
            {
                if (true)
                    return new OrQueryNode(clauses);
            }
        } else {
            {
                if (true)
                    return first;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryNode ConjQuery(CharSequence field) throws ParseException {
        QueryNode first, c;
        Vector clauses = null;
        first = Query(field);
        label_2: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case AND:
                    ;
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    break label_2;
            }
            jj_consume_token(AND);
            c = Query(field);
            if (clauses == null) {
                clauses = new Vector();
                clauses.addElement(first);
            }
            clauses.addElement(c);
        }
        if (clauses != null) {
            {
                if (true)
                    return new AndQueryNode(clauses);
            }
        } else {
            {
                if (true)
                    return first;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryNode Query(CharSequence field) throws ParseException {
        Vector clauses = null;
        QueryNode c, first = null;
        first = Clause(field);
        label_3: while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case NOT:
                case FUNCTION:
                case LPAREN:
                case QUOTED:
                case TERM:
                case REGEXPTERM:
                case RANGEIN_START:
                case RANGEEX_START:
                case NUMBER:
                    ;
                    break;
                default:
                    jj_la1[5] = jj_gen;
                    break label_3;
            }
            c = Clause(field);
            if (c == null) {
                break label_3;
            } else {
                if (clauses == null) {
                    clauses = new Vector();
                    clauses.addElement(first);
                }
            }
            clauses.addElement(c);
        }
        if (clauses != null) {
            {
                if (true)
                    return new AndQueryNode(clauses);
            }
        } else {
            {
                if (true)
                    return first;
            }
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryNode Clause(CharSequence field) throws ParseException {
        QueryNode q;
        Token fieldToken = null, boost = null;
        boolean group = false;
        if (jj_2_1(2)) {
            fieldToken = jj_consume_token(TERM);
            jj_consume_token(OP_COLON);
            field = EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
        } else {
            ;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case NOT: {
                if (true)
                    return null;
            }
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FUNCTION:
            case QUOTED:
            case TERM:
            case REGEXPTERM:
            case RANGEIN_START:
            case RANGEEX_START:
            case NUMBER:
                q = Term(field);
                break;
            case NOT:
                jj_consume_token(NOT); {
                if (true)
                    return null;
            }
                break;
            case LPAREN:
                jj_consume_token(LPAREN);
                q = ModClause(field);
                jj_consume_token(RPAREN);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case CARAT:
                        jj_consume_token(CARAT);
                        boost = jj_consume_token(NUMBER);
                        break;
                    default:
                        jj_la1[6] = jj_gen;
                        ;
                }
                group = true;
                break;
            default:
                jj_la1[7] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if (boost != null) {
            float f = (float) 1.0;
            try {
                f = Float.valueOf(boost.image).floatValue();
                // avoid boosting null queries, such as those caused by stop words
                if (q != null) {
                    q = new BoostQueryNode(q, f);
                }
            } catch (Exception ignored) {
                /*
                 * Should this be handled somehow? (defaults to "no boost", if boost number is invalid)
                 */
            }
        }
        if (group) {
            q = new GroupQueryNode(q);
        }
        {
            if (true)
                return q;
        }
        throw new Error("Missing return statement in function");
    }

    final public QueryNode Term(CharSequence field) throws ParseException {
        Token term, boost = null, fuzzySlop = null, goop1, goop2;
        boolean fuzzy = false;
        boolean regexp = false;
        boolean startInc = false;
        boolean endInc = false;
        QueryNode q = null;
        FieldQueryNode qLower, qUpper;
        float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case FUNCTION:
            case TERM:
            case REGEXPTERM:
            case NUMBER:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case FUNCTION:
                        term = jj_consume_token(FUNCTION);
                        q = new FunctionQueryNode(EscapeQuerySyntaxImpl.discardEscapeChar(term.image, new char[] {'(', ')', ',', '"', '\'', '\\'}, false),
                                        term.beginColumn, term.endColumn);
                        break;
                    case TERM:
                        term = jj_consume_token(TERM);
                        q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
                        break;
                    case REGEXPTERM:
                        term = jj_consume_token(REGEXPTERM);
                        regexp = true;
                        break;
                    case NUMBER:
                        term = jj_consume_token(NUMBER);
                        break;
                    default:
                        jj_la1[8] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case FUZZY_SLOP:
                        fuzzySlop = jj_consume_token(FUZZY_SLOP);
                        fuzzy = true;
                        break;
                    default:
                        jj_la1[9] = jj_gen;
                        ;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case CARAT:
                        jj_consume_token(CARAT);
                        boost = jj_consume_token(NUMBER);
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case FUZZY_SLOP:
                                fuzzySlop = jj_consume_token(FUZZY_SLOP);
                                fuzzy = true;
                                break;
                            default:
                                jj_la1[10] = jj_gen;
                                ;
                        }
                        break;
                    default:
                        jj_la1[11] = jj_gen;
                        ;
                }
                if (fuzzy) {
                    float fms = defaultMinSimilarity;
                    try {
                        fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
                    } catch (Exception ignored) {}
                    if (fms < 0.0f) {
                        {
                            if (true)
                                throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
                        }
                    } else if (fms >= 1.0f && fms != (int) fms) {
                        {
                            if (true)
                                throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));
                        }
                    }
                    q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
                } else if (regexp) {
                    String s = term.image.substring(1, term.image.length() - 1);
                    UnescapedCharSequence ucs = EscapeQuerySyntaxImpl.discardEscapeChar(s, new char[] {'/'}, false);
                    q = new RegexpQueryNode(field, ucs, 0, ucs.length());
                }
                break;
            case RANGEIN_START:
            case RANGEEX_START:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case RANGEIN_START:
                        jj_consume_token(RANGEIN_START);
                        startInc = true;
                        break;
                    case RANGEEX_START:
                        jj_consume_token(RANGEEX_START);
                        break;
                    default:
                        jj_la1[12] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case RANGE_GOOP:
                        goop1 = jj_consume_token(RANGE_GOOP);
                        break;
                    case RANGE_QUOTED:
                        goop1 = jj_consume_token(RANGE_QUOTED);
                        break;
                    default:
                        jj_la1[13] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case RANGE_TO:
                        jj_consume_token(RANGE_TO);
                        break;
                    default:
                        jj_la1[14] = jj_gen;
                        ;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case RANGE_GOOP:
                        goop2 = jj_consume_token(RANGE_GOOP);
                        break;
                    case RANGE_QUOTED:
                        goop2 = jj_consume_token(RANGE_QUOTED);
                        break;
                    default:
                        jj_la1[15] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case RANGEIN_END:
                        jj_consume_token(RANGEIN_END);
                        endInc = true;
                        break;
                    case RANGEEX_END:
                        jj_consume_token(RANGEEX_END);
                        break;
                    default:
                        jj_la1[16] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case CARAT:
                        jj_consume_token(CARAT);
                        boost = jj_consume_token(NUMBER);
                        break;
                    default:
                        jj_la1[17] = jj_gen;
                        ;
                }
                if (goop1.kind == RANGE_QUOTED) {
                    goop1.image = goop1.image.substring(1, goop1.image.length() - 1);
                }
                if (goop2.kind == RANGE_QUOTED) {
                    goop2.image = goop2.image.substring(1, goop2.image.length() - 1);
                }

                qLower = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
                qUpper = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
                q = new TermRangeQueryNode(qLower, qUpper, startInc ? true : false, endInc ? true : false);
                break;
            case QUOTED:
                term = jj_consume_token(QUOTED);
                q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length() - 1)),
                                term.beginColumn + 1, term.endColumn - 1);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case FUZZY_SLOP:
                        fuzzySlop = jj_consume_token(FUZZY_SLOP);
                        break;
                    default:
                        jj_la1[18] = jj_gen;
                        ;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case CARAT:
                        jj_consume_token(CARAT);
                        boost = jj_consume_token(NUMBER);
                        break;
                    default:
                        jj_la1[19] = jj_gen;
                        ;
                }
                int phraseSlop = 0;

                if (fuzzySlop != null) {
                    try {
                        phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
                        q = new SlopQueryNode(q, phraseSlop);
                    } catch (Exception ignored) {
                        /*
                         * Should this be handled somehow? (defaults to "no PhraseSlop", if slop number is invalid)
                         */
                    }
                }
                break;
            default:
                jj_la1[20] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if (boost != null) {
            float f = (float) 1.0;
            try {
                f = Float.valueOf(boost.image).floatValue();
                // avoid boosting null queries, such as those caused by stop words
                if (q != null) {
                    q = new BoostQueryNode(q, f);
                }
            } catch (Exception ignored) {
                /*
                 * Should this be handled somehow? (defaults to "no boost", if boost number is invalid)
                 */
            }
        }
        {
            if (true)
                return q;
        }
        throw new Error("Missing return statement in function");
    }

    final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    final private boolean jj_3_1() {
        if (jj_scan_token(TERM))
            return true;
        if (jj_scan_token(OP_COLON))
            return true;
        return false;
    }

    public AccumuloSyntaxParserTokenManager token_source;
    public Token token, jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    public boolean lookingAhead = false;
    private boolean jj_semLA;
    private int jj_gen;
    final private int[] jj_la1 = new int[21];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static {
        jj_la1_0();
        jj_la1_1();
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[] {0x6000, 0x6000, 0x8000, 0x4000, 0x2000, 0xf638000, 0x100000, 0xf638000, 0x9410000, 0x800000, 0x800000, 0x100000, 0x6000000,
                0x80000000, 0x10000000, 0x80000000, 0x60000000, 0x100000, 0x800000, 0x100000, 0xf610000,};
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[] {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[1];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    public AccumuloSyntaxParser(CharStream stream) {
        token_source = new AccumuloSyntaxParserTokenManager(stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(CharStream stream) {
        token_source.ReInit(stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    public AccumuloSyntaxParser(AccumuloSyntaxParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    public void ReInit(AccumuloSyntaxParserTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 21; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen)
                            c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static private final class LookaheadSuccess extends Error {}

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null)
                jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind)
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            throw jj_ls;
        return false;
    }

    final public Token getNextToken() {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    final private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private Vector<int[]> jj_expentries = new Vector<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100)
            return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
                int[] oldentry = (int[]) (e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists)
                        break;
                }
            }
            if (!exists)
                jj_expentries.addElement(jj_expentry);
            if (pos != 0)
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[33];
        for (int i = 0; i < 33; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 21; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 33; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    final public void enable_tracing() {}

    final public void disable_tracing() {}

    final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 1; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {}
        }
        jj_rescan = false;
    }

    final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
